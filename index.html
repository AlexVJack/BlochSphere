<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Rotating Sphere with White Dots</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: black;
      }
    </style>
  </head>
  <body>
    <!-- Include Three.js from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Create the scene and camera
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      // Move the camera to the center of the sphere
      camera.position.z = 5;

      // Create the renderer and attach it to the DOM
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Create a group to hold our points (dots)
      const group = new THREE.Group();
      scene.add(group);

      // Parameters for the sphere of dots
      const numPoints = 1000; // Number of dots
      const radius = 1;       // Radius of the sphere
      const positions = new Float32Array(numPoints * 3);

      // Generate points uniformly distributed on the sphere
      for (let i = 0; i < numPoints; i++) {
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        positions[i * 3] = x;
        positions[i * 3 + 1] = y;
        positions[i * 3 + 2] = z;
      }

      // Create buffer geometry and add the positions
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );

      // Create the points material (white dots)
      const material = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.01
      });

      // Create and add the points object to the group
      const points = new THREE.Points(geometry, material);
      group.add(points);

      // === Add a second sphere (outer sphere) ===
        // Create a new group for the outer sphere
        const group2 = new THREE.Group();
        scene.add(group2);

        // Parameters for the outer sphere of dots
        const numPoints2 = 2000;  // More stars for the outer sphere
        const radius2 = 3;        // Bigger sphere radius
        const positions2 = new Float32Array(numPoints2 * 3);

        // Generate points uniformly distributed on the outer sphere
        for (let i = 0; i < numPoints2; i++) {
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = radius2 * Math.sin(phi) * Math.cos(theta);
        const y = radius2 * Math.sin(phi) * Math.sin(theta);
        const z = radius2 * Math.cos(phi);
        positions2[i * 3] = x;
        positions2[i * 3 + 1] = y;
        positions2[i * 3 + 2] = z;
        }

        // Create buffer geometry, material, and points for the outer sphere
        const geometry2 = new THREE.BufferGeometry();
        geometry2.setAttribute("position", new THREE.BufferAttribute(positions2, 3));

        const material2 = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.01
        });

        const points2 = new THREE.Points(geometry2, material2);
        group2.add(points2);

        // === Add a second sphere (outer sphere) ===
        // Create a new group for the outer sphere
        const group3 = new THREE.Group();
        scene.add(group3);

        // Parameters for the outer sphere of dots
        const numPoints3 = 1500;  // More stars for the outer sphere
        const radius3 = 2;        // Bigger sphere radius
        const positions3 = new Float32Array(numPoints2 * 3);

        // Generate points uniformly distributed on the outer sphere
        for (let i = 0; i < numPoints3; i++) {
        const theta = Math.random() * 2 * Math.PI;
        const phi = Math.acos(2 * Math.random() - 1);
        const x = radius3 * Math.sin(phi) * Math.cos(theta);
        const y = radius3 * Math.sin(phi) * Math.sin(theta);
        const z = radius3 * Math.cos(phi);
        positions3[i * 3] = x;
        positions3[i * 3 + 1] = y;
        positions3[i * 3 + 2] = z;
        }

        // Create buffer geometry, material, and points for the outer sphere
        const geometry3 = new THREE.BufferGeometry();
        geometry3.setAttribute("position", new THREE.BufferAttribute(positions3, 3));

        const material3 = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.01
        });

        const points3 = new THREE.Points(geometry3, material3);
        group3.add(points3);


      // Define the rotation axis from top right to bottom right.
      // In this case, we use the vector (1, 0, -1) normalized.
      const axis = new THREE.Vector3(1, 0, -1).normalize();
      const rotationSpeed = 0.0007;

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);
        // Rotate the group around the specified axis
        group.rotateOnAxis(axis, rotationSpeed);
        group2.rotateOnAxis(axis, rotationSpeed);
        group3.rotateOnAxis(axis, rotationSpeed);
        renderer.render(scene, camera);
      }
      animate();

      // Update the renderer and camera on window resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>